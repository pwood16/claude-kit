#!/bin/zsh
# spawn-agent - Spawn a new Claude agent in a git worktree
#
# Usage: spawn-agent <worktree-name> [prompt] [--mode interactive|print|ralph] [--prd <file>] [--max-iterations N] [--completion-promise TEXT]
#
# Creates a git worktree and opens a new terminal with Claude
# working in that worktree. Optionally provide a prompt and mode.
#
# Modes:
#   interactive (default) - Agent stays in REPL after prompt, terminal stays open
#   print               - Agent completes prompt and exits, terminal auto-closes
#   ralph               - Ralph Loop: iteratively improves until completion promise or max iterations
#
# Examples:
#   spawn-agent feature-login "Add login form to the frontend"
#   spawn-agent bugfix-auth --mode print
#   spawn-agent research-task "Investigate options" --mode interactive

set -e

worktree_name=${1:?"Usage: spawn-agent <worktree-name> [prompt] [--mode interactive|print|ralph] [--prd <file>] [--max-iterations N] [--completion-promise TEXT]"}
shift

# Parse arguments for --mode flag and ralph options
mode="interactive"  # default
max_iterations=0    # default: unlimited (0)
completion_promise="" # default: empty
prd_file=""         # default: empty (no PRD)
args=()
while [[ $# -gt 0 ]]; do
  case $1 in
    --mode)
      mode="$2"
      shift 2
      ;;
    --prd)
      prd_file="$2"
      shift 2
      ;;
    --max-iterations)
      max_iterations="$2"
      shift 2
      ;;
    --completion-promise)
      completion_promise="$2"
      shift 2
      ;;
    *)
      args+=("$1")
      shift
      ;;
  esac
done

# Validate mode
if [[ "$mode" != "interactive" && "$mode" != "print" && "$mode" != "ralph" ]]; then
  echo "Error: Invalid mode '$mode'. Must be 'interactive', 'print', or 'ralph'" >&2
  exit 1
fi

# Validate ralph mode requirements
if [[ "$mode" == "ralph" && -z "$prd_file" ]]; then
  echo "Error: Ralph mode requires --prd <file> to specify a spec file" >&2
  exit 1
fi

# Set default completion promise for ralph mode if not provided
if [[ "$mode" == "ralph" && -z "$completion_promise" ]]; then
  completion_promise="TASK COMPLETE"
fi

# Validate PRD file exists if provided
if [[ -n "$prd_file" ]]; then
  # Convert to absolute path
  if [[ "$prd_file" != /* ]]; then
    prd_file="$(pwd)/$prd_file"
  fi

  if [[ ! -f "$prd_file" ]]; then
    echo "Error: PRD file not found: $prd_file" >&2
    exit 1
  fi
fi

# Reconstruct prompt from remaining args
prompt="${args[*]:-Begin working in this worktree. Check git status and recent commits to understand the context.}"

# Verify we're in a git repository
if ! git rev-parse --git-dir &> /dev/null; then
  echo "Error: Not in a git repository" >&2
  exit 1
fi

repo_root=$(git rev-parse --show-toplevel)
repo_name=$(basename "$repo_root")
worktree_path="$repo_root/$worktree_name"

# Check if worktree already exists
if [[ -d "$worktree_path" ]]; then
  echo "Worktree already exists at: $worktree_path"
  echo "Using existing worktree..."
else
  # Create worktree at repo root using absolute path
  echo "Creating worktree: $worktree_name..."
  if ! git worktree add "$worktree_path" -b "$worktree_name" 2>/dev/null; then
    # Branch might already exist, try without -b
    git worktree add "$worktree_path" "$worktree_name" 2>/dev/null || {
      echo "Error: Failed to create worktree '$worktree_name'" >&2
      exit 1
    }
  fi
fi

# Create a simple prompt file
prompts_dir="$repo_root/.agent-prompts"
mkdir -p "$prompts_dir"
prompt_file="$prompts_dir/$worktree_name.md"

# Write the prompt file in parts to safely handle special characters in $prompt
cat > "$prompt_file" <<EOF
# Task: $worktree_name

## Context

You are working in a git worktree for: **$worktree_name**

- **Repository:** $repo_name
- **Working Directory:** $worktree_path

## Instructions

EOF

# Append the user's prompt without shell expansion
printf '%s\n' "$prompt" >> "$prompt_file"

# Append the footer
cat >> "$prompt_file" <<'EOF'

## Notes

- This is a git worktree, so you have an isolated working directory
- Commit your changes as you make progress
- When done, you can merge this branch back to main

---

Begin working.
EOF

echo "Worktree created at: $worktree_path"
echo "Prompt file created at: $prompt_file"
echo "Spawning Claude agent..."

# Check for available terminal emulator (prefer ghostty, fallback to alacritty)
if command -v ghostty &> /dev/null; then
  terminal="ghostty"
elif command -v alacritty &> /dev/null; then
  terminal="alacritty"
else
  echo "Error: No supported terminal found. Install ghostty or alacritty." >&2
  exit 1
fi

# Build the shell command based on mode
if [[ "$mode" == "print" ]]; then
  # Print mode: use -p flag, terminal closes after completion
  shell_cmd="
    cd '$worktree_path' && \
    echo 'Starting Claude agent for: $worktree_name (print mode)' && \
    echo 'Repository: $repo_name' && \
    echo 'Worktree: $worktree_path' && \
    echo 'Mode: print (terminal will close when complete)' && \
    echo '---' && \
    claude --dangerously-skip-permissions -p \"\$(cat \"$prompt_file\")\"
  "
elif [[ "$mode" == "ralph" ]]; then
  # Ralph mode: run the ralph-loop script

  prd_basename=$(basename "$prd_file")
  prd_dest="$worktree_path/$prd_basename"

  # Copy PRD file to worktree
  cp "$prd_file" "$prd_dest"

  # Get the directory where this script lives (to find ralph-loop)
  script_dir="$(cd "$(dirname "$0")" && pwd)"
  ralph_loop_script="$script_dir/ralph-loop"

  # Build shell command that runs the ralph-loop script
  shell_cmd="cd '$worktree_path' && '$ralph_loop_script' --prd '$prd_basename' --max-iterations $max_iterations --completion-promise '$completion_promise'"
else
  # Interactive mode: exec directly into claude (replaces shell process)
  shell_cmd="
    cd '$worktree_path' && \
    echo 'Starting Claude agent for: $worktree_name (interactive mode)' && \
    echo 'Repository: $repo_name' && \
    echo 'Worktree: $worktree_path' && \
    echo 'Mode: interactive (use Ctrl+O to see thinking, /rename to name session)' && \
    echo '---' && \
    exec claude --dangerously-skip-permissions \"\$(cat \"$prompt_file\")\"
  "
fi

# Spawn new terminal with Claude using the prompt file
# Set smaller window dimensions: 120 columns x 20 lines
# Set distinctive background color based on mode
if [[ "$mode" == "ralph" ]]; then
  # Ralph mode: purple background to distinguish from other modes
  title="Claude [Ralph]: $repo_name/$worktree_name"
  bg_color="#2e1a4a"
else
  # Interactive/print modes: dark blue background
  title="Claude: $repo_name/$worktree_name"
  bg_color="#1a1a2e"
fi

if [[ "$terminal" == "ghostty" ]]; then
  # Use 'open -n -a' to properly bring window to foreground on macOS
  open -n -a Ghostty --args --title="$title" \
    --background="$bg_color" \
    -e zsh -ic "$shell_cmd"
else
  alacritty --title "$title" \
    -o window.dimensions.columns=120 \
    -o window.dimensions.lines=20 \
    -o "colors.primary.background=\"$bg_color\"" \
    -e zsh -ic "$shell_cmd" >/dev/null 2>&1 &
  disown
fi

echo "Agent spawned in new terminal (mode: $mode)"
