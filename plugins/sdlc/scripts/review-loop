#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.10"
# dependencies = []
# ///
"""
review-loop - Automated code review and triage loop.

This script runs an iterative code review loop:
1. Run ACR (Automated Code Review) with specified configuration
2. Parse findings from ACR output
3. Display structured review summary
4. Invoke Claude to diagnose findings (real issues vs false positives)
5. Fix real issues and add explanatory comments for false positives
6. Repeat until LGTM or max iterations reached

Usage:
    review-loop
    review-loop --max-iterations 3
    review-loop --num-reviewers 5 --model claude --verbose
    review-loop --log review-output.log
"""

import argparse
import json
import os
import re
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Any, Optional, TypedDict


class ReviewLoopConfig(TypedDict, total=False):
    """Configuration structure for review_loop section in .claude-kit."""
    model: str  # Model to use for triage (default: "claude")
    max_iterations: int  # Max review iterations
    verbose: bool  # Enable verbose logging


class ACRConfig(TypedDict, total=False):
    """Configuration structure for acr section in .claude-kit."""
    num_reviewers: int  # Number of reviewers for ACR (default: 5)


def log(step: str, message: str) -> None:
    """Log a message with timestamp and step indicator."""
    timestamp = datetime.now().strftime("%H:%M:%S")
    print(f"[{timestamp}] [{step}] {message}", flush=True)


def find_git_root() -> Optional[Path]:
    """Find the git root directory, if in a git repository."""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--show-toplevel"],
            capture_output=True,
            text=True,
            check=False
        )
        if result.returncode == 0:
            return Path(result.stdout.strip())
    except Exception:
        pass
    return None


def discover_config_files(verbose: bool = False) -> list[Path]:
    """
    Discover .claude-kit configuration files in order of precedence (lowest to highest).

    Search order:
    1. User home directory (~/.claude-kit)
    2. Git root directory (./.claude-kit)
    3. Current working directory (./.claude-kit)

    Returns list of existing config file paths in precedence order (lowest first).
    """
    config_files = []

    # 1. User home directory (lowest precedence)
    home_config = Path.home() / ".claude-kit"
    if home_config.exists():
        config_files.append(home_config)
        if verbose:
            log("CONFIG", f"Found config: {home_config}")

    # 2. Git root directory (if in a git repo and different from cwd)
    git_root = find_git_root()
    if git_root:
        git_config = git_root / ".claude-kit"
        cwd = Path.cwd()
        if git_config.exists() and git_root != cwd:
            config_files.append(git_config)
            if verbose:
                log("CONFIG", f"Found config: {git_config}")

    # 3. Current working directory (highest precedence)
    cwd_config = Path.cwd() / ".claude-kit"
    if cwd_config.exists():
        config_files.append(cwd_config)
        if verbose:
            log("CONFIG", f"Found config: {cwd_config}")

    return config_files


def load_config_file(config_path: Path, verbose: bool = False) -> dict[str, Any]:
    """
    Load and parse a configuration file.

    Returns the parsed configuration or an empty dict on error.
    """
    try:
        with open(config_path, 'r') as f:
            config = json.load(f)

        if verbose:
            log("CONFIG", f"Loaded config from: {config_path}")

        return config
    except json.JSONDecodeError as e:
        log("ERROR", f"Invalid JSON in config file {config_path}: {e}")
        sys.exit(1)
    except Exception as e:
        log("ERROR", f"Error reading config file {config_path}: {e}")
        sys.exit(1)


def merge_configs(configs: list[dict[str, Any]]) -> dict[str, Any]:
    """
    Merge multiple configuration dictionaries with later configs taking precedence.

    Performs a deep merge of nested dictionaries.
    """
    result = {}

    for config in configs:
        for key, value in config.items():
            if isinstance(value, dict) and key in result and isinstance(result[key], dict):
                # Deep merge for nested dicts
                result[key] = {**result[key], **value}
            else:
                result[key] = value

    return result


def validate_config(config: dict[str, Any]) -> tuple[ReviewLoopConfig, ACRConfig]:
    """
    Validate configuration values and return validated settings.

    Returns a tuple of (review_loop_config, acr_config) or exits on validation error.
    """
    review_loop_config = config.get("review_loop", {})
    acr_config = config.get("acr", {})

    # Validate that review_loop is a dict/object, not array or other type
    if not isinstance(review_loop_config, dict):
        log("ERROR", f"review_loop config must be a JSON object (dict), got: {type(review_loop_config).__name__}")
        sys.exit(1)

    # Validate that acr is a dict/object, not array or other type
    if not isinstance(acr_config, dict):
        log("ERROR", f"acr config must be a JSON object (dict), got: {type(acr_config).__name__}")
        sys.exit(1)

    # Validate max_iterations
    if "max_iterations" in review_loop_config:
        value = review_loop_config["max_iterations"]
        if not isinstance(value, int) or value < 1:
            log("ERROR", f"max_iterations must be a positive integer, got: {value}")
            sys.exit(1)

    # Validate verbose
    if "verbose" in review_loop_config:
        value = review_loop_config["verbose"]
        if not isinstance(value, bool):
            log("ERROR", f"verbose must be a boolean (true/false), got: {value}")
            sys.exit(1)

    # Validate model
    if "model" in review_loop_config:
        value = review_loop_config["model"]
        if not isinstance(value, str) or not value.strip():
            log("ERROR", f"review_loop.model must be a non-empty string, got: {value}")
            sys.exit(1)

    # Validate acr.num_reviewers
    if "num_reviewers" in acr_config:
        value = acr_config["num_reviewers"]
        if not isinstance(value, int) or value < 1:
            log("ERROR", f"acr.num_reviewers must be a positive integer, got: {value}")
            sys.exit(1)

    return review_loop_config, acr_config


def load_configuration(verbose: bool = False) -> tuple[ReviewLoopConfig, ACRConfig]:
    """
    Load and merge configuration from all discovered config files.

    Returns a tuple of (review_loop_config, acr_config).
    Precedence: defaults < user home < git root < current dir < CLI args
    """
    config_files = discover_config_files(verbose)

    if not config_files and verbose:
        log("CONFIG", "No configuration files found, using defaults")

    # Load all config files
    configs = [load_config_file(path, verbose) for path in config_files]

    # Merge configurations
    merged_config = merge_configs(configs)

    # Validate and extract settings
    review_loop_config, acr_config = validate_config(merged_config)

    return review_loop_config, acr_config


def parse_arguments() -> argparse.Namespace:
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description="Run automated code review loop with ACR",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s
  %(prog)s --max-iterations 3
  %(prog)s --num-reviewers 5 --model claude
  %(prog)s --verbose --log review.log
        """
    )

    parser.add_argument(
        "--max-iterations", "-m",
        type=int,
        default=5,
        help="Maximum review/fix cycles (default: 5)"
    )

    parser.add_argument(
        "--num-reviewers", "-r",
        type=int,
        default=5,
        help="Number of ACR reviewers (default: 5)"
    )

    parser.add_argument(
        "--model",
        type=str,
        default="claude",
        help="Model to use for triage (default: claude)"
    )

    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Enable verbose logging"
    )

    parser.add_argument(
        "--log", "--log-file",
        type=str,
        dest="log_file",
        help="Path to log file for detailed execution capture"
    )

    return parser.parse_args()


def main() -> int:
    """Main entry point for review-loop."""
    args = parse_arguments()

    # Load configuration from .claude-kit files
    review_loop_config, acr_config = load_configuration(verbose=args.verbose)

    # Merge CLI arguments with config (CLI args take precedence)
    # max_iterations: CLI arg overrides config
    max_iterations = args.max_iterations
    if max_iterations == 5 and "max_iterations" in review_loop_config:
        # Default value from CLI, use config value
        max_iterations = review_loop_config["max_iterations"]

    # num_reviewers: CLI arg overrides config
    num_reviewers = args.num_reviewers
    if num_reviewers == 5 and "num_reviewers" in acr_config:
        # Default value from CLI, use config value
        num_reviewers = acr_config["num_reviewers"]

    # model: CLI arg overrides config
    model = args.model
    if model == "claude" and "model" in review_loop_config:
        # Default value from CLI, use config value
        model = review_loop_config["model"]

    # verbose: CLI flag overrides config
    verbose = args.verbose
    if not verbose and "verbose" in review_loop_config:
        # Flag not set, use config value
        verbose = review_loop_config["verbose"]

    # Display final configuration
    print(f"Review Loop Configuration:")
    print(f"  Max iterations: {max_iterations}")
    print(f"  Number of reviewers: {num_reviewers}")
    print(f"  Model: {model}")
    print(f"  Verbose: {verbose}")
    if args.log_file:
        print(f"  Log file: {args.log_file}")
    print()

    if verbose:
        log("CONFIG", "Configuration loading complete")

    # TODO: Implement review execution
    # TODO: Implement triage logic
    # TODO: Implement main review loop
    # TODO: Implement logging

    print("Review loop implementation in progress...")
    return 0


if __name__ == "__main__":
    sys.exit(main())
